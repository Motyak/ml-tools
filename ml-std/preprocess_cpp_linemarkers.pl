#!/usr/bin/perl
use strict;
use warnings;

my $FILENAME = $ARGV[0];
my @stack;

sub ml_comment {
    my ($msg) = @_;
    my $ML_COMMENT_WIDTH = 80;
    $msg = "=== mlcpp: ${msg} ===";
    no warnings "numeric"; # when `x` op rhs is negative => same as 0
    my $comment = "\"" . $msg . "=" x ($ML_COMMENT_WIDTH - 2 - length($msg)) . "\"";
    return $comment;
}

while (my $line = <STDIN>) {
    chomp($line); # remove newline character

    # add Monlang comment on inclusion
    if ($line =~ /^# [1-9][0-9]* "(.*)" 1$/) {
        my $include_name = $1;
        push(@stack, $include_name);
        my $msg = "BEGIN ${include_name}";
        my $comment = ml_comment($msg);
        print("${comment}\n");
    }

    # add Monlang comment when returning from inclusion
    elsif ($line =~ /^# [1-9][0-9]* "(.*)" 2$/) {
        @stack || die;
        my $back_to = $1;
        my $popped = pop(@stack);
        my $stack = @stack;
        my $msg = "END ${popped}";
        if ($stack == 0) {
            $msg .= " (finally back to " . ($FILENAME // $back_to) . ")";
        }
        else {
            $msg .= " (back to ${back_to})";
        }
        my $comment = ml_comment($msg);
        print("${comment}\n");
    }

    # discard other linemarkers generated by cpp
    elsif ($line =~ /^# \d/) {
        ;
    }

    # discard some empty lines generated by cpp
    elsif ($line =~ /^ +$/) {
        ;
    }

    # discard NULL_DIRECTIVE__
    elsif ($line =~ /^ #/) {
        ;
    }

    else {
        print("${line}\n")
    }
}
